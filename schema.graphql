# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"A node, according to the Relay specification."
interface Node {
    "The id of this node."
    id: ID!
}

type AclResource implements Node {
    _id: String!
    dependsOn: [AclResource]
    id: ID!
    name: String!
}

type AclResourceCollection implements Node {
    _id: String!
    dependsOn: [AclResourceCollection]
    id: ID!
    name: String!
}

type AclResourceItem implements Node {
    _id: String!
    dependsOn: [AclResourceItem]
    id: ID!
    name: String!
}

type AclRole implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [AclResource]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [AclResource]
}

type AclRoleCollection implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [AclResourceCollection]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [AclResourceCollection]
}

type AclRoleItem implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [AclResourceItem]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [AclResourceItem]
}

type ClassGroup implements Node {
    createdBy: UserItem
    id: ID!
    section: String!
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: UserItem
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        createdAt: UserFilter_createdAt,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        role_resources_id: String,
        role_resources_id_list: [String],
        role_resources_name: String,
        role_resources_name_list: [String]
    ): UserItemConnection
    year: Int!
}

"Connection for ClassGroup."
type ClassGroupConnection {
    edges: [ClassGroupEdge]
    pageInfo: ClassGroupPageInfo!
    totalCount: Int!
}

"Edge of ClassGroup."
type ClassGroupEdge {
    cursor: String!
    node: ClassGroup
}

"Information about the current page."
type ClassGroupPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type GroupCollection implements Node {
    createdAt: String!
    createdBy: UserCollection
    id: ID!
    section: String!
    subjectRelations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): SubjectCollectionConnection
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        createdAt: UserFilter_createdAt,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        role_resources_id: String,
        role_resources_id_list: [String],
        role_resources_name: String,
        role_resources_name_list: [String]
    ): UserCollectionConnection
}

"Connection for GroupCollection."
type GroupCollectionConnection {
    edges: [GroupCollectionEdge]
    pageInfo: GroupCollectionPageInfo!
    totalCount: Int!
}

"Edge of GroupCollection."
type GroupCollectionEdge {
    cursor: String!
    node: GroupCollection
}

"Information about the current page."
type GroupCollectionPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type GroupItem implements Node {
    createdAt: String!
    createdBy: UserItem
    id: ID!
    section: String!
    subjectRelations(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): SubjectItemConnection
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        createdAt: UserFilter_createdAt,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        role_resources_id: String,
        role_resources_id_list: [String],
        role_resources_name: String,
        role_resources_name_list: [String]
    ): UserItemConnection
}

type Mutation {
    "ChangePasswords a User."
    changePasswordUser(input: changePasswordUserInput!): changePasswordUserPayload
    "Creates a AclRole."
    createAclRole(input: createAclRoleInput!): createAclRolePayload
    "Creates a ClassGroup."
    createClassGroup(input: createClassGroupInput!): createClassGroupPayload
    "Creates a Group."
    createGroup(input: createGroupInput!): createGroupPayload
    "Creates a Subject."
    createSubject(input: createSubjectInput!): createSubjectPayload
    "Creates a SubjectType."
    createSubjectType(input: createSubjectTypeInput!): createSubjectTypePayload
    "Creates a User."
    createUser(input: createUserInput!): createUserPayload
    "Deletes a ClassGroup."
    deleteClassGroup(input: deleteClassGroupInput!): deleteClassGroupPayload
    "Deletes a Group."
    deleteGroup(input: deleteGroupInput!): deleteGroupPayload
    "Edits a Subject."
    editSubject(input: editSubjectInput!): editSubjectPayload
    "Updates a AclRole."
    updateAclRole(input: updateAclRoleInput!): updateAclRolePayload
    "Updates a ClassGroup."
    updateClassGroup(input: updateClassGroupInput!): updateClassGroupPayload
    "Updates a Group."
    updateGroup(input: updateGroupInput!): updateGroupPayload
    "Updates a SubjectType."
    updateSubjectType(input: updateSubjectTypeInput!): updateSubjectTypePayload
    "Updates a User."
    updateUser(input: updateUserInput!): updateUserPayload
}

type Query {
    aclResources: [AclResourceCollection]
    aclRole(id: ID!): AclRoleItem
    aclRoles: [AclRoleCollection]
    classGroup(id: ID!): ClassGroup
    classGroups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ClassGroupConnection
    getToken(email: String!, password: String!): Token
    group(id: ID!): GroupItem
    groups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        id: String,
        id_list: [String],
        "Returns the last n elements from the list."
        last: Int,
        section: String
    ): GroupCollectionConnection
    meUser: User
    node(id: ID!): Node
    subject(id: ID!): SubjectItem
    subjectType(id: ID!): SubjectType
    subjectTypes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): SubjectTypeConnection
    subjects(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): SubjectCollectionConnection
    user(id: ID!): UserItem
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        createdAt: UserFilter_createdAt,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        role_resources_id: String,
        role_resources_id_list: [String],
        role_resources_name: String,
        role_resources_name_list: [String]
    ): UserCollectionConnection
}

type SubjectCollection implements Node {
    classGroup: ClassGroup
    group: GroupCollection
    id: ID!
    subjectType: SubjectType
    teacher: UserCollection
}

"Connection for SubjectCollection."
type SubjectCollectionConnection {
    edges: [SubjectCollectionEdge]
    pageInfo: SubjectCollectionPageInfo!
    totalCount: Int!
}

"Edge of SubjectCollection."
type SubjectCollectionEdge {
    cursor: String!
    node: SubjectCollection
}

"Information about the current page."
type SubjectCollectionPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type SubjectItem implements Node {
    classGroup: ClassGroup
    group: GroupItem
    id: ID!
    subjectType: SubjectType
    teacher: UserItem
}

"Connection for SubjectItem."
type SubjectItemConnection {
    edges: [SubjectItemEdge]
    pageInfo: SubjectItemPageInfo!
    totalCount: Int!
}

"Edge of SubjectItem."
type SubjectItemEdge {
    cursor: String!
    node: SubjectItem
}

"Information about the current page."
type SubjectItemPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type SubjectType implements Node {
    id: ID!
    name: String
}

"Connection for SubjectType."
type SubjectTypeConnection {
    edges: [SubjectTypeEdge]
    pageInfo: SubjectTypePageInfo!
    totalCount: Int!
}

"Edge of SubjectType."
type SubjectTypeEdge {
    cursor: String!
    node: SubjectType
}

"Information about the current page."
type SubjectTypePageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type Token implements Node {
    id: ID!
    "Use token in header like this: 'Authorization: Bearer {token}'"
    token: String!
    user: User!
}

type User implements Node {
    _id: String!
    classGroup: ClassGroup
    createdAt: String!
    "email of user"
    email: String!
    firstname: String!
    id: ID!
    lastname: String!
    role: AclRole!
}

type UserCollection implements Node {
    _id: String!
    classGroup: ClassGroup
    createdAt: String!
    "email of user"
    email: String!
    firstname: String!
    id: ID!
    lastname: String!
    role: AclRoleCollection!
}

"Connection for UserCollection."
type UserCollectionConnection {
    edges: [UserCollectionEdge]
    pageInfo: UserCollectionPageInfo!
    totalCount: Int!
}

"Edge of UserCollection."
type UserCollectionEdge {
    cursor: String!
    node: UserCollection
}

"Information about the current page."
type UserCollectionPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type UserItem implements Node {
    _id: String!
    classGroup: ClassGroup
    createdAt: String!
    "email of user"
    email: String!
    firstname: String!
    id: ID!
    lastname: String!
    name: String @deprecated(reason : "Replaced with firstname and lastname")
    "The hashed password"
    password: String!
    role: AclRoleItem!
    roles: Iterable!
    username: String! @deprecated(reason : "use email instead")
}

"Connection for UserItem."
type UserItemConnection {
    edges: [UserItemEdge]
    pageInfo: UserItemPageInfo!
    totalCount: Int!
}

"Edge of UserItem."
type UserItemEdge {
    cursor: String!
    node: UserItem
}

"Information about the current page."
type UserItemPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type changePasswordUserPayload {
    clientMutationId: String
    user: UserItem
}

type createAclResourceNestedPayload implements Node {
    _id: String!
    dependsOn: [createAclResourceNestedPayload]
    id: ID!
    name: String!
}

type createAclRoleNestedPayload implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [createAclResourceNestedPayload]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [createAclResourceNestedPayload]
}

type createAclRolePayload {
    aclRole: AclRoleItem
    clientMutationId: String
}

type createClassGroupNestedPayload implements Node {
    _id: String!
    createdBy: createUserNestedPayload
    id: ID!
    section: String!
    subjectRelations: createSubjectNestedPayloadConnection
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: createUserNestedPayload
    users: createUserNestedPayloadConnection
    year: Int!
}

type createClassGroupPayload {
    classGroup: createClassGroupPayloadData
    clientMutationId: String
}

type createClassGroupPayloadData implements Node {
    _id: String!
    createdBy: createUserNestedPayload
    id: ID!
    section: String!
    subjectRelations: createSubjectNestedPayloadConnection
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: createUserNestedPayload
    users: createUserNestedPayloadConnection
    year: Int!
}

type createGroupNestedPayload implements Node {
    _id: String!
    createdAt: String!
    createdBy: createUserNestedPayload
    id: ID!
    section: String!
    subjectRelations: createSubjectNestedPayloadConnection
    users: createUserNestedPayloadConnection
}

type createGroupPayload {
    clientMutationId: String
    group: createGroupPayloadData
}

type createGroupPayloadData implements Node {
    _id: String!
    createdAt: String!
    createdBy: createUserNestedPayload
    id: ID!
    section: String!
    subjectRelations: createSubjectNestedPayloadConnection
    users: createUserNestedPayloadConnection
}

type createSubjectNestedPayload implements Node {
    classGroup: createClassGroupNestedPayload
    group: createGroupNestedPayload
    id: ID!
    subjectType: createSubjectTypeNestedPayload
    teacher: createUserNestedPayload
}

"Connection for createSubjectNestedPayload."
type createSubjectNestedPayloadConnection {
    edges: [createSubjectNestedPayloadEdge]
    pageInfo: createSubjectNestedPayloadPageInfo!
    totalCount: Int!
}

"Edge of createSubjectNestedPayload."
type createSubjectNestedPayloadEdge {
    cursor: String!
    node: createSubjectNestedPayload
}

"Information about the current page."
type createSubjectNestedPayloadPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type createSubjectPayload {
    clientMutationId: String
    subject: createSubjectPayloadData
}

type createSubjectPayloadData implements Node {
    classGroup: createClassGroupNestedPayload
    group: createGroupNestedPayload
    id: ID!
    subjectType: createSubjectTypeNestedPayload
    teacher: createUserNestedPayload
}

type createSubjectTypeNestedPayload implements Node {
    id: ID!
    name: String
}

type createSubjectTypePayload {
    clientMutationId: String
    subjectType: createSubjectTypePayloadData
}

type createSubjectTypePayloadData implements Node {
    id: ID!
    name: String
}

type createUserNestedPayload implements Node {
    _id: String!
    classGroup: createClassGroupNestedPayload
    createdAt: String!
    "email of user"
    email: String!
    firstname: String!
    id: ID!
    lastname: String!
    role: createAclRoleNestedPayload!
}

"Connection for createUserNestedPayload."
type createUserNestedPayloadConnection {
    edges: [createUserNestedPayloadEdge]
    pageInfo: createUserNestedPayloadPageInfo!
    totalCount: Int!
}

"Edge of createUserNestedPayload."
type createUserNestedPayloadEdge {
    cursor: String!
    node: createUserNestedPayload
}

"Information about the current page."
type createUserNestedPayloadPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type createUserPayload {
    clientMutationId: String
    user: createUserPayloadData
}

type createUserPayloadData implements Node {
    _id: String!
    classGroup: createClassGroupNestedPayload
    createdAt: String!
    "email of user"
    email: String!
    firstname: String!
    id: ID!
    lastname: String!
    role: createAclRoleNestedPayload!
}

type deleteClassGroupPayload {
    classGroup: ClassGroup
    clientMutationId: String
}

type deleteGroupPayload {
    clientMutationId: String
    group: GroupItem
}

type editAclResourceNestedPayload implements Node {
    _id: String!
    dependsOn: [editAclResourceNestedPayload]
    id: ID!
    name: String!
}

type editAclRoleNestedPayload implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [editAclResourceNestedPayload]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [editAclResourceNestedPayload]
}

type editClassGroupNestedPayload implements Node {
    _id: String!
    createdAt: String!
    createdBy: editUserNestedPayload
    id: ID!
    section: String!
    subjectRelations: editSubjectNestedPayloadConnection
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: editUserNestedPayload
    users: editUserNestedPayloadConnection
    usersToChange: Iterable!
    year: Int!
}

type editGroupNestedPayload implements Node {
    _id: String!
    createdAt: String!
    createdBy: editUserNestedPayload
    id: ID!
    section: String!
    subjectRelations: editSubjectNestedPayloadConnection
    users: editUserNestedPayloadConnection
}

type editSubjectNestedPayload implements Node {
    classGroup: editClassGroupNestedPayload
    group: editGroupNestedPayload
    id: ID!
    subjectType: editSubjectTypeNestedPayload
    teacher: editUserNestedPayload
}

"Connection for editSubjectNestedPayload."
type editSubjectNestedPayloadConnection {
    edges: [editSubjectNestedPayloadEdge]
    pageInfo: editSubjectNestedPayloadPageInfo!
    totalCount: Int!
}

"Edge of editSubjectNestedPayload."
type editSubjectNestedPayloadEdge {
    cursor: String!
    node: editSubjectNestedPayload
}

"Information about the current page."
type editSubjectNestedPayloadPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type editSubjectPayload {
    clientMutationId: String
    subject: editSubjectPayloadData
}

type editSubjectPayloadData implements Node {
    classGroup: editClassGroupNestedPayload
    group: editGroupNestedPayload
    id: ID!
    subjectType: editSubjectTypeNestedPayload
    teacher: editUserNestedPayload
}

type editSubjectTypeNestedPayload implements Node {
    _id: String!
    id: ID!
    name: String
}

type editUserNestedPayload implements Node {
    _id: String!
    classGroup: editClassGroupNestedPayload
    createdAt: String!
    "email of user"
    email: String!
    firstname: String!
    id: ID!
    lastname: String!
    name: String @deprecated(reason : "Replaced with firstname and lastname")
    "The hashed password"
    password: String!
    role: editAclRoleNestedPayload!
    roles: Iterable!
    username: String! @deprecated(reason : "use email instead")
}

"Connection for editUserNestedPayload."
type editUserNestedPayloadConnection {
    edges: [editUserNestedPayloadEdge]
    pageInfo: editUserNestedPayloadPageInfo!
    totalCount: Int!
}

"Edge of editUserNestedPayload."
type editUserNestedPayloadEdge {
    cursor: String!
    node: editUserNestedPayload
}

"Information about the current page."
type editUserNestedPayloadPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type updateAclResourceNestedPayload implements Node {
    _id: String
    dependsOn: [updateAclResourceNestedPayload]
    id: ID!
    name: String
}

type updateAclRoleNestedPayload implements Node {
    _id: String
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String
    resource: [updateAclResourceNestedPayload]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [updateAclResourceNestedPayload]
}

type updateAclRolePayload {
    aclRole: AclRoleItem
    clientMutationId: String
}

type updateClassGroupNestedPayload implements Node {
    _id: String
    createdBy: updateUserNestedPayload
    id: ID!
    section: String
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: updateUserNestedPayload
    users: updateUserNestedPayloadConnection
    year: Int
}

type updateClassGroupPayload {
    classGroup: updateClassGroupPayloadData
    clientMutationId: String
}

type updateClassGroupPayloadData implements Node {
    _id: String
    createdBy: updateUserNestedPayload
    id: ID!
    section: String
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: updateUserNestedPayload
    users: updateUserNestedPayloadConnection
    year: Int
}

type updateGroupNestedPayload implements Node {
    _id: String
    createdAt: String
    createdBy: updateUserNestedPayload
    id: ID!
    section: String
    subjectRelations: updateSubjectNestedPayloadConnection
    users: updateUserNestedPayloadConnection
}

type updateGroupPayload {
    clientMutationId: String
    group: updateGroupPayloadData
}

type updateGroupPayloadData implements Node {
    _id: String
    createdAt: String
    createdBy: updateUserNestedPayload
    id: ID!
    section: String
    subjectRelations: updateSubjectNestedPayloadConnection
    users: updateUserNestedPayloadConnection
}

type updateSubjectNestedPayload implements Node {
    _id: String
    classGroup: updateClassGroupNestedPayload
    group: updateGroupNestedPayload
    id: ID!
    subjectType: updateSubjectTypeNestedPayload
    teacher: updateUserNestedPayload
}

"Connection for updateSubjectNestedPayload."
type updateSubjectNestedPayloadConnection {
    edges: [updateSubjectNestedPayloadEdge]
    pageInfo: updateSubjectNestedPayloadPageInfo!
    totalCount: Int!
}

"Edge of updateSubjectNestedPayload."
type updateSubjectNestedPayloadEdge {
    cursor: String!
    node: updateSubjectNestedPayload
}

"Information about the current page."
type updateSubjectNestedPayloadPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type updateSubjectTypeNestedPayload implements Node {
    id: ID!
    name: String
}

type updateSubjectTypePayload {
    clientMutationId: String
    subjectType: updateSubjectTypePayloadData
}

type updateSubjectTypePayloadData implements Node {
    id: ID!
    name: String
}

type updateUserNestedPayload implements Node {
    _id: String
    classGroup: updateClassGroupNestedPayload
    createdAt: String
    "email of user"
    email: String
    firstname: String
    id: ID!
    lastname: String
    role: updateAclRoleNestedPayload
}

"Connection for updateUserNestedPayload."
type updateUserNestedPayloadConnection {
    edges: [updateUserNestedPayloadEdge]
    pageInfo: updateUserNestedPayloadPageInfo!
    totalCount: Int!
}

"Edge of updateUserNestedPayload."
type updateUserNestedPayloadEdge {
    cursor: String!
    node: updateUserNestedPayload
}

"Information about the current page."
type updateUserNestedPayloadPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type updateUserPayload {
    clientMutationId: String
    user: updateUserPayloadData
}

type updateUserPayloadData implements Node {
    _id: String
    classGroup: updateClassGroupNestedPayload
    createdAt: String
    "email of user"
    email: String
    firstname: String
    id: ID!
    lastname: String
    role: updateAclRoleNestedPayload
}

input UserFilter_createdAt {
    after: String
    before: String
    strictly_after: String
    strictly_before: String
}

input changePasswordUserInput {
    clientMutationId: String
    newPassword: String!
    oldPassword: String!
}

input createAclRoleInput {
    clientMutationId: String
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [String]
}

input createClassGroupInput {
    clientMutationId: String
    section: String!
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: String
    users: [String]
    year: Int!
}

input createGroupInput {
    clientMutationId: String
    section: String!
    users: [String]
}

input createSubjectInput {
    classGroup: String
    clientMutationId: String
    group: String
    subjectType: String
    teacher: String
}

input createSubjectTypeInput {
    clientMutationId: String
    name: String
}

input createUserInput {
    classGroup: String
    clientMutationId: String
    "email of user"
    email: String!
    firstname: String!
    lastname: String!
    role: String!
}

input deleteClassGroupInput {
    clientMutationId: String
    id: ID!
}

input deleteGroupInput {
    clientMutationId: String
    id: ID!
}

input editSubjectInput {
    classGroup: String
    clientMutationId: String
    group: String
    id: ID!
    subjectType: String
    teacher: String
}

input updateAclResourceInput {
    _id: String
    clientMutationId: String
    dependsOn: [String]
    id: ID!
    name: String
}

input updateAclRoleInput {
    clientMutationId: String
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String
    resource: [updateAclResourceInput!]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [String]
}

input updateClassGroupInput {
    clientMutationId: String
    id: ID!
    section: String
    "Teacher needs to be user with resource GROUP_TEACHER"
    teacher: String
    users: [String]
    year: Int
}

input updateGroupInput {
    clientMutationId: String
    id: ID!
    section: String
    users: [String]
}

input updateSubjectTypeInput {
    clientMutationId: String
    id: ID!
    name: String
}

input updateUserInput {
    classGroup: String
    clientMutationId: String
    "email of user"
    email: String
    firstname: String
    id: ID!
    lastname: String
    role: String
}


"The `Iterable` scalar type represents an array or a Traversable with any kind of data."
scalar Iterable
