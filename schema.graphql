# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"A node, according to the Relay specification."
interface Node {
    "The id of this node."
    id: ID!
}

type AclResource implements Node {
    _id: String!
    dependsOn: [AclResource]
    id: ID!
    name: String!
}

type AclResourceCollection implements Node {
    _id: String!
    dependsOn: [AclResourceCollection]
    id: ID!
    name: String!
}

type AclResourceItem implements Node {
    _id: String!
    dependsOn: [AclResourceItem]
    id: ID!
    name: String!
}

type AclRole implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [AclResource]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [AclResource]
}

type AclRoleCollection implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [AclResourceCollection]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [AclResourceCollection]
}

type AclRoleItem implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [AclResourceItem]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [AclResourceItem]
}

type Mutation {
    "Creates a AclRole."
    createAclRole(input: createAclRoleInput!): createAclRolePayload
    "CreateBatchs a User."
    createBatchUser(input: createBatchUserInput!): createBatchUserPayload
    "Creates a User."
    createUser(input: createUserInput!): createUserPayload
    "Updates a AclRole."
    updateAclRole(input: updateAclRoleInput!): updateAclRolePayload
    "Updates a User."
    updateUser(input: updateUserInput!): updateUserPayload
}

type Query {
    aclResources: [AclResourceCollection]
    aclRole(id: ID!): AclRoleItem
    aclRoles: [AclRoleCollection]
    getToken(password: String!, username: String!): Token
    meUser: User
    node(id: ID!): Node
    user(id: ID!): UserItem
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        id: String,
        id_list: [String],
        "Returns the last n elements from the list."
        last: Int,
        name: String
    ): UserCollectionConnection
}

type Token implements Node {
    id: ID!
    "Use token in header like this: 'Authorization: Bearer {token}'"
    token: String!
    user: User!
}

type User implements Node {
    _id: String!
    createdAt: String!
    "email of user"
    email: String!
    id: ID!
    name: String!
    role: AclRole!
}

type UserCollection implements Node {
    _id: String!
    createdAt: String!
    "email of user"
    email: String!
    id: ID!
    name: String!
    role: AclRoleCollection!
}

"Connection for UserCollection."
type UserCollectionConnection {
    edges: [UserCollectionEdge]
    pageInfo: UserCollectionPageInfo!
    totalCount: Int!
}

"Edge of UserCollection."
type UserCollectionEdge {
    cursor: String!
    node: UserCollection
}

"Information about the current page."
type UserCollectionPageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type UserItem implements Node {
    _id: String!
    createdAt: String!
    "email of user"
    email: String!
    id: ID!
    name: String!
    "The hashed password"
    password: String!
    role: AclRoleItem!
    roles: Iterable!
    username: String!
}

type createAclResourceNestedPayload implements Node {
    _id: String!
    dependsOn: [createAclResourceNestedPayload]
    id: ID!
    name: String!
}

type createAclRoleNestedPayload implements Node {
    _id: String!
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    resource: [createAclResourceNestedPayload]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [createAclResourceNestedPayload]
}

type createAclRolePayload {
    aclRole: AclRoleItem
    clientMutationId: String
}

type createBatchUserPayload {
    clientMutationId: String
    user: UserItem
}

type createUserPayload {
    clientMutationId: String
    user: createUserPayloadData
}

type createUserPayloadData implements Node {
    _id: String!
    createdAt: String!
    "email of user"
    email: String!
    id: ID!
    name: String!
    role: createAclRoleNestedPayload!
}

type updateAclResourceNestedPayload implements Node {
    _id: String
    dependsOn: [updateAclResourceNestedPayload]
    id: ID!
    name: String
}

type updateAclRoleNestedPayload implements Node {
    _id: String
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String
    resource: [updateAclResourceNestedPayload]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [updateAclResourceNestedPayload]
}

type updateAclRolePayload {
    aclRole: AclRoleItem
    clientMutationId: String
}

type updateUserPayload {
    clientMutationId: String
    user: updateUserPayloadData
}

type updateUserPayloadData implements Node {
    _id: String
    createdAt: String
    "email of user"
    email: String
    id: ID!
    name: String
    role: updateAclRoleNestedPayload
}

input createAclRoleInput {
    clientMutationId: String
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String!
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [String]
}

input createBatchUserInput {
    clientMutationId: String
    input: [createAclRoleInput!]
}

input createUserInput {
    clientMutationId: String
    "email of user"
    email: String!
    name: String!
    role: String!
}

input updateAclResourceInput {
    _id: String
    clientMutationId: String
    dependsOn: [String]
    id: ID!
    name: String
}

input updateAclRoleInput {
    clientMutationId: String
    id: ID!
    """

    Example format: ROLE_ADMIN.
    Must start with 'ROLE_' and name cant be longer than 20 letters.
    (regex: ^ROLE_[A-Z]{1,20}$/m)
    """
    name: String
    resource: [updateAclResourceInput!]
    "Must be an array IRIs (acl_resources/<uuid>) of existing resources"
    resources: [String]
}

input updateUserInput {
    clientMutationId: String
    "email of user"
    email: String
    id: ID!
    name: String
    role: String
}


"The `Iterable` scalar type represents an array or a Traversable with any kind of data."
scalar Iterable
